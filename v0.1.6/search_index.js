var documenterSearchIndex = {"docs":
[{"location":"immanants/#Immanants","page":"Immanants","title":"Immanants","text":"First discovered by Kostant and then extended by de Guise et al., immanants of unitary matrices can be computed by certain sums of group functions.\n\nBriefly, in this section of the documentation, I give some examples of this relation. First, compute the unitary matrix:\n\nα1,β1,γ1 = rand(Float64,3)\nblock12_a = su2_block(4,1,(α1,β1,γ1))\nα2,β2 = rand(Float64,2)\nblock23_a = su2_block(4,2,(α2,β2,α2))\nα3,β3,γ3 = rand(Float64,3)\nblock12_b = su2_block(4,1,(α3,β3,γ3))\nα4,β4 = rand(Float64,3)\nblock34_a = su2_block(4,3,(α4,β4,α4))\nα5,β5 = rand(Float64,2)\nblock23_b = su2_block(4,2,(α5,β5,α5))\nα6,β6,γ6 = rand(Float64,3)\nblock12_c = su2_block(4,1,(α6,β6,γ6))\n\nmat4 = block12_a * block23_a * block12_b * block34_a * block23_b * block12_c\n\nThen obtain the states with a given p-weight (see the Alex et al. paper).\n\nbasis = basis_states([3,0,0,0])\n\nstate_x = filter(x -> pweight(x) == [0,1,1,1], basis)[1]\nstate_y = filter(x -> pweight(x) == [1,0,2,0], basis)[1]\n\nFinally, show the equality between the permanent and a group function.\n\ngroup_function([3,0,0,0], state_x, state_y, mat4) ≈ permanent(mat4[[1,2,3], [2,2,4]])/sqrt(2)","category":"section"},{"location":"quantum_optics/#Basic-quantum-optics-using-GroupFunctions.jl","page":"Basic quantum optics","title":"Basic quantum optics using GroupFunctions.jl","text":"","category":"section"},{"location":"quantum_optics/#Introduction","page":"Basic quantum optics","title":"Introduction","text":"Linear optical networks (beamsplitters, phase shifters, etc. )act on n optical modes via SU(n) transformations. A key object is the transition amplitude between Fock states under such transformations.\n\nConsider N photons distributed across n modes. The Fock state m_1 m_2 ldots m_nrangle with sum_i m_i = N transforms under passive linear optics as: m_1 ldots m_nrangle xrightarrowU sum_m c_mm(U) m_1 ldots m_nrangle where U in mathrmSU(n) mixes the mode creation operators: a^dagger_i mapsto sum_j U_ij a^dagger_j.\n\nThe amplitudes c_mm(U) are matrix elements of SU(n) irreducible representations, specifically, the symmetric irrep lambda = N 0 ldots 0, corresponding to a single-row Young tableau. This is because bosonic states are symmetric under particle exchange. Importantly, for symmetric irreps, the p-weight of a Gelfand-Tsetlin pattern (used internally by this library) directly gives the occupation numbers, more natural in quantum optics.  \n\nThe basic items to translate between quantum optics and GT pattern language are thus the following:\n\nDefine photon number subspace  λ = [N, 0, ..., 0] \nEnumerate the basis of the above subspace using GT patterns  basis = basis_states(λ) \nEach of the basis elements corresponds to the Fock state with occupation number provided by  pweight(pattern) \nTransition amplitude is read out by group_function(λ, final, initial, U), where U is the SU(n) unitary in previous paragraphs (e.g. provided by su2_block(n, i, (α, β, γ))), final and initial are the final and initial states (written as GT patterns).","category":"section"},{"location":"quantum_optics/#Basis-states-and-occupation-numbers","page":"Basic quantum optics","title":"Basis states and occupation numbers","text":"The Hilbert space of N photons in n modes has dimension binomN+n-1n-1. We enumerate basis states as GT patterns:\n\nusing GroupFunctions\n\n# Two photons in three modes\nλ = [2, 0, 0]\nbasis = basis_states(λ)\n\n# Each GT pattern corresponds to a Fock state via pweight\nfor b in basis\n    occ = pweight(b)\n    println(\"|\", join(occ, \",\"), \"⟩\")\nend\n\nExpected output:\n\n|2,0,0⟩\n|1,1,0⟩\n|1,0,1⟩\n|0,2,0⟩\n|0,1,1⟩\n|0,0,2⟩","category":"section"},{"location":"quantum_optics/#Building-SU(n)-matrices","page":"Basic quantum optics","title":"Building SU(n) matrices","text":"Any SU(n) matrix can be decomposed into SU(2) blocks acting on adjacent modes. The function su2_block(n, i, (α, β, γ)) embeds an SU(2) rotation (parametrized by Euler angles) into modes i and i+1:\n\n# Beamsplitter on modes 1-2 (θ = π/2 for 50:50)\nθ = float(π)/2\nBS_12 = su2_block(3, 1, (0., θ, 0.))\n\n# Beamsplitter on modes 2-3\nBS_23 = su2_block(3, 2, (0., θ, 0.))\n\n# Compose: first BS_12, then BS_23\nU = BS_12 * BS_23\n\nTODO: Verify sign/phase conventions for su2_block. The beamsplitter mixing a^dagger_1 mapsto frac1sqrt2(a^dagger_1 + a^dagger_2) corresponds to which Euler angles?","category":"section"},{"location":"quantum_optics/#Transition-amplitudes","page":"Basic quantum optics","title":"Transition amplitudes","text":"The amplitude langle m  U  m rangle is computed via group_function:\n\nλ = [2, 0, 0]\nbasis = basis_states(λ)\n\n# Initial state: |2,0,0⟩\ninitial = basis[findfirst(b -> pweight(b) == [2,0,0], basis)]\n\n# Final state: |1,1,0⟩\nfinal = basis[findfirst(b -> pweight(b) == [1,1,0], basis)]\n\n# Amplitude\namp = group_function(λ, final, initial, U)\nprob = abs2(amp)","category":"section"},{"location":"quantum_optics/#Example:-Hong-Ou-Mandel-interference","page":"Basic quantum optics","title":"Example: Hong-Ou-Mandel interference","text":"Two photons entering a 50:50 beamsplitter from different input ports:\n\nInitial state: 11rangle\nBeamsplitter: a^dagger_1 mapsto frac1sqrt2(a^dagger_1 + a^dagger_2), a^dagger_2 mapsto frac1sqrt2(a^dagger_1 - a^dagger_2)\n\nλ = [2, 0]\nbasis = basis_states(λ)\n\ninitial = basis[findfirst(b -> pweight(b) == [1,1], basis)]\n\nθ = float(π)/2\nBS = su2_block(2, 1, (0., θ, 0.))\n\nfor final in basis\n    amp = group_function(λ, final, initial, BS)\n    println(\"|\", join(pweight(final), \",\"), \"⟩: \", round(abs2(amp), digits=4))\nend\n\nExpected (HOM effect): The 11rangle to 11rangle amplitude vanishes due to destructive interference. Output is frac1sqrt2(20rangle + 02rangle).\n\nTODO: Verify output matches expected HOM signature. Check if beamsplitter convention gives the correct phases.","category":"section"},{"location":"sum_rules/#Sum-rules","page":"Sum rules","title":"Sum rules","text":"First, prepare the matrix using the simple factorization.\n\nα1,β1,γ1 = rand(Float64,3)\nblock12_a = su2_block(4,1,(α1,β1,γ1))\nα2,β2 = rand(Float64,2)\nblock23_a = su2_block(4,2,(α2,β2,α2))\nα3,β3,γ3 = rand(Float64,3)\nblock12_b = su2_block(4,1,(α3,β3,γ3))\nα4,β4 = rand(Float64,3)\nblock34_a = su2_block(4,3,(α4,β4,α4))\nα5,β5 = rand(Float64,2)\nblock23_b = su2_block(4,2,(α5,β5,α5))\nα6,β6,γ6 = rand(Float64,3)\nblock12_c = su2_block(4,1,(α6,β6,γ6))\n\nmat4 = block12_a * block23_a * block12_b\nmat4c1 = block12_a * block23_a * block12_b * block34_a * block23_b\n\nThen obtain the basis states:\n\nbasis = basis_states([2,0,0,0])\n\nFinally, compute the rate:\n\nrate1 = abs(group_function([2,0,0,0], basis[9], basis[9], mat4))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[4], mat4))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[7], mat4))^2\nrate2 = abs(group_function([2,0,0,0], basis[9], basis[9], mat4c1))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[4], mat4c1))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[7], mat4c1))^2\nrate1 ≈ rate2","category":"section"},{"location":"states/#States","page":"Basis states","title":"States","text":"The preferred method to denote the basis states is by using Gelfand–Tsetlin patterns.   Without going into detail, this can be seen in the paper by Alex et al.   The top row of the pattern is the partition that labels the irrep.   The rest of the entries should satisfy the betweenness condition, explained below.  \n\nI start with an example. (Due to LaTeX limitations, I denote the pattern as left-justified.)   The pattern is:  \n\nbeginpmatrix\nc_00  c_01  c_02 \nc_10  c_11  \nc_20    \nendpmatrix\n\nThe betweenness condition imposes the requirement:\n\nc_i-1j geq c_ij geq c_i-1j+1\n\nTo introduce a GTPattern, write an array of arrays with the content of the pattern as the argument:\n\nGTPattern([[2,1,0], [2,1], [2]])","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Build Status) (Image: )","category":"section"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"Julia package to compute entries of the irreducible representations of the unitary group (D-functions or group functions). It supports both numerical and symbolic group functions.","category":"section"},{"location":"#[Documentation](https://davidamaro.github.io/GroupFunctions.jl/dev/)","page":"Getting started","title":"Documentation","text":"","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"#Julia-is-already-installed","page":"Getting started","title":"Julia is already installed","text":"You can install the package directly from the repository:\n\nuser@machine:~$ mkdir new_code \nuser@machine:~$ cd new_code\nuser@machine:~$ julia --project=.\njulia> # here you need to press the character `]`; the prompt turns blue\npkg > add https://github.com/davidamaro/GroupFunctions.jl","category":"section"},{"location":"#Getting-Julia","page":"Getting started","title":"Getting Julia","text":"Mac: Use juliaup. Installing Julia via brew is not recommended.\nLinux: Use the appropriate package manager (e.g., sudo pacman -S julia).\nWindows: Run winget install julia -s msstore in your terminal and follow the steps.","category":"section"},{"location":"#Computing-a-single-group-function-(symbolical)","page":"Getting started","title":"Computing a single group function (symbolical)","text":"irrep = [2, 1, 0]\nbasis = basis_states(irrep)\noutput = group_function(irrep, basis[1], basis[3])\njulia_to_mma(output)","category":"section"},{"location":"#Contact","page":"Getting started","title":"Contact","text":"For questions and suggestions: david.amaroalcala@ucalgary.ca","category":"section"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/#Functions","page":"Documentation","title":"Functions","text":"","category":"section"},{"location":"documentation/#Example:-SU(3)-character-check","page":"Documentation","title":"Example: SU(3) character check","text":"using GroupFunctions\nusing RandomMatrices\nusing LinearAlgebra: det, eigvals, tr\n\nirrep = [2, 1, 0]\nU = rand(Haar(2), 3)  # 3×3 Haar-random unitary matrix\nU_su = U / det(U)^(1/3)\n\nrep, _states = group_function(irrep, U_su)\nlambdas = eigvals(U_su)\nideal_character = lambdas[1]/lambdas[2] + lambdas[2]/lambdas[1] +\n                  lambdas[1]/lambdas[3] + lambdas[3]/lambdas[1] +\n                  lambdas[2]/lambdas[3] + lambdas[3]/lambdas[2] + 2\ntr(rep) ≈ ideal_character","category":"section"},{"location":"documentation/#Gelfand-Tsetlin-patterns","page":"Documentation","title":"Gelfand-Tsetlin patterns","text":"GT patterns are used to denote the basis states.","category":"section"},{"location":"documentation/#Construction-of-matrices","page":"Documentation","title":"Construction of matrices","text":"SU(2) blocks are used to construct unitary matrices. For SU(d) characters, use character_weyl to evaluate the Weyl/Schur determinant formula.","category":"section"},{"location":"documentation/#GroupFunctions.group_function","page":"Documentation","title":"GroupFunctions.group_function","text":"group_function(λ::Irrep, tu::YoungTableau, tv::YoungTableau)\n\nReturns the symbolic group function corresponding to irrep λ and Young tableaux tu and tv.\n\nExample:\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, tab_u::YTableau, tab_v::YTableau; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Young tableaux and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\ntab_u::YTableau: First Young tableau\ntab_v::YTableau: Second Young tableau\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nComplex: Group function evaluated\n\nNotes:\n\nUses SymEngine for symbolic computation\nInvolves matrix operations and coset calculations\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern)\n\nReturns the symbolic group function corresponding to irrep λ and GT patterns tu and tv.\n\nExample:\n\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, pat_u::GTPattern, pat_v::GTPattern; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Gelfand-Tsetlin patterns and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\npat_u::GTPattern: First Gelfand-Tsetlin pattern\npat_v::GTPattern: Second Gelfand-Tsetlin pattern\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nBasic: Computed polynomial expression in SymEngine format\n\nNotes:\n\nConverts GT patterns to Young tableaux for calculations\nUses SymEngine for symbolic computation\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and a pair of GT patterns tu and tv.\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and STYT tu and tv.\n\nExample:\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\ngroup_function(λ::Irrep; verbose::Bool = false) -> Tuple{Matrix{Basic}, Vector{GTPattern}}\n\nCompute all symbolic group functions associated with the partition λ. The routine builds every valid GT pattern for λ and evaluates the group function for each pair.\n\nArguments:\n\nλ::Irrep: Partition describing the irrep\nverbose::Bool: Forwarded to the underlying pairwise group_function\n\nReturns:\n\nTuple: (values, patterns) where values[i,j] corresponds to group_function(λ, patterns[i], patterns[j]) and patterns is the basis returned by basis_states(λ)\n\n\n\n\n\ngroup_function(λ::Irrep, mat::Array{Complex{Float64}, 2}; verbose::Bool = false) -> Tuple{Matrix{ComplexF64}, Vector{GTPattern}}\n\nCompute all numeric group functions associated with the partition λ and a matrix mat. Generates the GT patterns for λ and evaluates every pair using the provided matrix.\n\nArguments:\n\nλ::Irrep: Partition describing the irrep\nmat::Array{Complex{Float64}, 2}: Matrix representing the SU(n) element\nverbose::Bool: Forwarded to the underlying pairwise group_function\n\nReturns:\n\nTuple: (values, patterns) where values[i,j] corresponds to group_function(λ, patterns[i], patterns[j], mat) and patterns is the basis returned by basis_states(λ)\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.character_weyl","page":"Documentation","title":"GroupFunctions.character_weyl","text":"character_weyl(λ::Irrep, mat::Array{Complex{Float64},2}) -> ComplexF64\n\nCompute the U(n) character using the Weyl/Schur determinant formula, without using the characteristic polynomial.\n\nNotes\n\nmat must be square; the length of λ must not exceed size(mat,1).\nThe formula evaluates the Schur polynomial at the eigenvalues of mat: det(z_i^(λ_j+n-j)) / det(z_i^(n-j)).\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.GTPattern","page":"Documentation","title":"GroupFunctions.GTPattern","text":"GTPattern(arrayofarrays) Stucture to hold Gelfand-Tsetlin patterns.  Data fields:\n\nrows\nlast_row, copied from rows during initialization (for internal algorithm purposes, mathematically irrelevant)\n\nTODO: either make it immutable, or somehow auto-change last_row upon change in rows (and vice versa).\n\nExample:\n\njulia> gt=GTPattern([[2,1,0],[2,1],[2]])\n│ 2   1   0 ╲\n│   2   1    〉\n│     2     ╱\n\n\njulia> gt.rows\n3-element Vector{Vector{Int64}}:\n [2, 1, 0]\n [2, 1]\n [2]\n\njulia> gt.last_row\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"type"},{"location":"documentation/#GroupFunctions.su2_block","page":"Documentation","title":"GroupFunctions.su2_block","text":"su2_block(size::Int, position::Int, angles::NTuple{3,Float64})\n\nEmbed a 2×2 SU(2) rotation defined by Euler angles (α, β, γ) into an size × size identity matrix, acting on rows/cols position and position+1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Index","page":"Index","title":"Index","text":"","category":"section"}]
}
