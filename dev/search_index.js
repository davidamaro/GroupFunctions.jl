var documenterSearchIndex = {"docs":
[{"location":"group_functions/#Group-Functions","page":"Calculation of group functions","title":"Group Functions","text":"","category":"section"},{"location":"group_functions/#The-problem:-mode-mixing-in-quantum-mechanics","page":"Calculation of group functions","title":"The problem: mode mixing in quantum mechanics","text":"Consider a system of n modes, each described by a creation operator a^dagger_i. A Fock state is built by applying creation operators to the vacuum:\n\nm_1 m_2 ldots m_nrangle = frac(a_1^dagger)^m_1 cdots (a_n^dagger)^m_nsqrtm_1 cdots m_n 0rangle\n\nNow suppose the modes get mixed by a unitary transformation U in mathrmU(n): a_i^dagger mapsto sum_j U_ij a_j^dagger\n\nWhat is the output state? Each creation operator in the original Fock state transforms according to the rule above. Expanding the product, we obtain a superposition of Fock states with coefficients that are polynomials in the matrix elements U_ij.\n\nThe function group_function computes these coefficients — the transition amplitudes langle m  U  m rangle. The presentation here is slightly more mathematical than a typical quantum optics treatment, for consistency with representation theory literature and to handle more general cases beyond bosons.","category":"section"},{"location":"group_functions/#Bosons:-the-permanent","page":"Calculation of group functions","title":"Bosons: the permanent","text":"For bosonic systems, consider the transition amplitude between an input Fock state mrangle and an output Fock state mrangle, both having N total particles. We follow the derivation of Scheel (2004).\n\nLabel the N particles by alpha = 1 ldots N, assigning each to its input mode via alpha mapsto i_alpha such that mode i appears m_i times (so, e.g. for ket210, (i_1 i_2 i_3)=(112)). Then:\n\nUmrangle = frac1sqrtprod_i m_i prod_i=1^n left(sum_j U_ij a_j^daggerright)^m_i 0rangle = frac1sqrtprod_i m_i sum_j_1 ldots j_N left(prod_alpha=1^N U_i_alpha j_alpharight) prod_alpha=1^N a_j_alpha^dagger 0rangle\n\nThe first step unfolds powers into labeled factors; the second is distributivity. \n\nSo now we have products of operators acting on the vacuum ket0; we wish to close it with a bra bram to calculate the matrix element. Let us act with the creatio operators on the vacuum and identify terms proportional to ketm there; then, the matrix element will be a sum of prefactors leading to ketm.  For terms where the tuple (j_1 ldots j_N) contains mode k exactly m_k times, the creation operators produce:\n\nprod_alpha=1^N a_j_alpha^dagger 0rangle = sqrtprod_j m_j mrangle\n\nThe sqrtm_j arises because m_j identical creation operators acting on vacuum give (a_j^dagger)^m_j0rangle = sqrtm_jm_jrangle_j. Denoting the constraint on (j_1 ldots j_N) as sim m:\n\nlangle m  U  m rangle = fracsqrtprod_j m_jsqrtprod_i m_i sum_(j_1ldotsj_N) sim m prod_alpha=1^N U_i_alpha j_alpha\n\nThe above expression can be shown to be expressible as a permanent of a properly constructed matrix. This is, by the way, the basis for boson sampling problems; computing the permanent is #P-hard (Aaronson & Arkhipov, 2011), making bosonic transition amplitudes classically intractable.\n\nThe relation is as follows: construct an N times N matrix M using output labeling beta mapsto j_beta (analogous to input): M_alphabeta = U_i_alpha j_beta. The permanent sums over all permutations sigma in S_N:\n\nmathrmperm(M) = sum_sigma in S_N prod_alpha=1^N U_i_alpha j_sigma(alpha)\n\nEach valid (j_1 ldots j_N) sim m corresponds to prod_j m_j permutations (permuting indices within each output mode). Therefore: sum_(j_1ldotsj_N) sim m prod_alpha U_i_alpha j_alpha = fracmathrmperm(M)prod_j m_j\n\nAs a result, we have\n\nlangle m  U  m rangle = fracmathrmperm(M)sqrtprod_i m_isqrtprod_j m_j\n\nExample: 3 modes, input mrangle = 201rangle, output mrangle = 111rangle.\n\nInput labeling (N=3 particles): (i_1 i_2 i_3) = (1 1 3) — two particles from mode 1, one from mode 3.\n\nOutput labeling: (j_1 j_2 j_3) = (1 2 3) — one particle into each mode.\n\nThe matrix M has entries M_alphabeta = U_i_alpha j_beta:\n\nM = beginpmatrix U_11  U_12  U_13  U_11  U_12  U_13  U_31  U_32  U_33 endpmatrix\n\nNote the repeated rows from m_1 = 2.\n\nIn representation-theoretic terms, bosonic Fock states live in the symmetric subspace, the irrep lambda = N 0 ldots 0.","category":"section"},{"location":"group_functions/#Fermions:-the-determinant","page":"Calculation of group functions","title":"Fermions: the determinant","text":"For fermions, the derivation parallels the bosonic case with three modifications: occupation numbers are restricted to m_i m_j in 01 (Pauli exclusion), leading to all normalization factors become sqrt0=sqrt1 = 1, and anticommutation introduces signs.\n\nThe expansion step has the aame structure as bosons:\n\nUmrangle = sum_j_1 ldots j_N left(prod_alpha=1^N U_i_alpha j_alpharight) a_j_1^dagger cdots a_j_N^dagger 0rangle\n\nTo project the result to final bra bram, consider the following. For a term to contribute to mrangle, the tuple (j_1 ldots j_N) must have all distinct entries (otherwise a_j^dagger a_j^dagger = 0), forming a permutation of the occupied output modes. Write j_alpha = j_sigma(alpha) where (j_1 ldots j_N) is the sorted list and sigma in S_N. Reordering to standard form introduces signs from the anticommutation relation (rectifying every transposition changes it: a_2^dagger a_1^dagger=-a_1^dagger a_2^dagger):\n\na_j_1^dagger cdots a_j_N^dagger 0rangle = mathrmsgn(sigma) cdot a_j_1^dagger cdots a_j_N^dagger 0rangle = mathrmsgn(sigma) mrangle\n\nAs a result,\n\nlangle m  U  m rangle = sum_sigma in S_N mathrmsgn(sigma) prod_alpha=1^N U_i_alpha j_sigma(alpha) = det(M)\n\nwhere M_alphabeta = U_i_alpha j_beta is the submatrix of U with rows = occupied input modes, columns = occupied output modes.\n\nUnlike permanents, determinants can be computed efficiently in O(N^3) time, which underlies the tractability of free-fermion systems.","category":"section"},{"location":"group_functions/#The-general-formula","page":"Calculation of group functions","title":"The general formula","text":"Both results share a common structure: a sum over permutations, weighted by representation-dependent coefficients, times a monomial in matrix elements. For bosons:\n\nlangle m  U  m rangle propto sum_sigma in S_N 1 cdot prod_alpha U_i_alpha j_sigma(alpha)\n\nand for fermions:\n\nlangle m  U  m rangle propto sum_sigma in S_N mathrmsgn(sigma) cdot prod_alpha U_i_alpha j_sigma(alpha)\n\nThe weights 1 and mathrmsgn(sigma) are the matrix elements of the trivial and sign representations of S_N, both one-dimensional.\n\nFor a general irrep lambda, the representation has dimension f^lambda  1, and the weight becomes a matrix element omega^lambda_ij(sigma) of the Young orthogonal representation. The general formula, due to Grabmeier & Kerber (1985), is:\n\nT^lambda_UV = frac1sqrtTheta^lambda_U Theta^lambda_V sum_gamma left( sum_sigma in S_alpha gamma S_beta omega^lambda_ij(sigma) right) X_f circ gamma g\n\nHere U V are semistandard tableaux labeling basis states (equivalent to GT patterns), Theta is a normalization factor generalizing sqrtm, and X_f circ gamma g is the monomial prod_k U_i_k j_k. The double coset decomposition S_alpha backslash S_N  S_beta groups permutations contributing the same monomial.\n\nThe partition lambda labels the symmetry type: N for bosons, 1^N for fermions, mixed shapes for particles with mixed exchange symmetry. The function group_function(λ, ...) evaluates this formula.","category":"section"},{"location":"docstrings/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/#Functions","page":"Documentation","title":"Functions","text":"","category":"section"},{"location":"documentation/#Gelfand-Tsetlin-patterns","page":"Documentation","title":"Gelfand-Tsetlin patterns","text":"GT patterns are used to denote the basis states.","category":"section"},{"location":"documentation/#Construction-of-matrices","page":"Documentation","title":"Construction of matrices","text":"SU(2) blocks are used to construct unitary matrices.","category":"section"},{"location":"documentation/#Young-Tableaux-Operations","page":"Documentation","title":"Young Tableaux Operations","text":"Young tableaux are fundamental combinatorial objects used in representation theory. These functions provide tools for constructing and manipulating Young tableaux.","category":"section"},{"location":"documentation/#GT-Pattern-Generation","page":"Documentation","title":"GT Pattern Generation","text":"Functions for generating and iterating through Gelfand-Tsetlin patterns, which form a basis for irreducible representations.","category":"section"},{"location":"documentation/#Weight-Functions","page":"Documentation","title":"Weight Functions","text":"Weight functions extract different types of weights from Gelfand-Tsetlin patterns, useful for quantum optics and physical applications.","category":"section"},{"location":"documentation/#Content-and-Matrix-Generation","page":"Documentation","title":"Content and Matrix Generation","text":"Functions for computing content vectors, coefficients, and matrix representations of irreducible representations.","category":"section"},{"location":"documentation/#SU(n)-Matrix-Construction","page":"Documentation","title":"SU(n) Matrix Construction","text":"Advanced functions for constructing special unitary matrices using various factorization methods and Euler angle parametrizations.","category":"section"},{"location":"documentation/#Utility-Functions","page":"Documentation","title":"Utility Functions","text":"Conversion utilities for interfacing with other symbolic computation systems.","category":"section"},{"location":"documentation/#GroupFunctions.group_function","page":"Documentation","title":"GroupFunctions.group_function","text":"group_function(λ::Irrep, tu::YoungTableau, tv::YoungTableau)\n\nReturns the symbolic group function corresponding to irrep λ and Young tableaux tu and tv.\n\nExample:\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, tab_u::YTableau, tab_v::YTableau; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Young tableaux and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\ntab_u::YTableau: First Young tableau\ntab_v::YTableau: Second Young tableau\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nComplex: Group function evaluated\n\nNotes:\n\nUses SymEngine for symbolic computation\nInvolves matrix operations and coset calculations\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern)\n\nReturns the symbolic group function corresponding to irrep λ and GT patterns tu and tv.\n\nExample:\n\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, pat_u::GTPattern, pat_v::GTPattern; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Gelfand-Tsetlin patterns and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\npat_u::GTPattern: First Gelfand-Tsetlin pattern\npat_v::GTPattern: Second Gelfand-Tsetlin pattern\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nBasic: Computed polynomial expression in SymEngine format\n\nNotes:\n\nConverts GT patterns to Young tableaux for calculations\nUses SymEngine for symbolic computation\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and a pair of GT patterns tu and tv.\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and STYT tu and tv.\n\nExample:\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\ngroup_function(λ::Irrep; verbose::Bool = false) -> Tuple{Matrix{Basic}, Vector{GTPattern}}\n\nCompute all symbolic group functions associated with the partition λ. The routine builds every valid GT pattern for λ and evaluates the group function for each pair.\n\nArguments:\n\nλ::Irrep: Partition describing the irrep\nverbose::Bool: Forwarded to the underlying pairwise group_function\n\nReturns:\n\nTuple: (values, patterns) where values[i,j] corresponds to group_function(λ, patterns[i], patterns[j]) and patterns is the basis returned by basis_states(λ)\n\n\n\n\n\ngroup_function(λ::Irrep, mat::Array{Complex{Float64}, 2}; verbose::Bool = false) -> Tuple{Matrix{ComplexF64}, Vector{GTPattern}}\n\nCompute all numeric group functions associated with the partition λ and a matrix mat. Generates the GT patterns for λ and evaluates every pair using the provided matrix.\n\nArguments:\n\nλ::Irrep: Partition describing the irrep\nmat::Array{Complex{Float64}, 2}: Matrix representing the SU(n) element\nverbose::Bool: Forwarded to the underlying pairwise group_function\n\nReturns:\n\nTuple: (values, patterns) where values[i,j] corresponds to group_function(λ, patterns[i], patterns[j], mat) and patterns is the basis returned by basis_states(λ)\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.GTPattern","page":"Documentation","title":"GroupFunctions.GTPattern","text":"GTPattern(arrayofarrays) Stucture to hold Gelfand-Tsetlin patterns.  Data fields:\n\nrows\nlast_row, copied from rows during initialization (for internal algorithm purposes, mathematically irrelevant)\n\nTODO: either make it immutable, or somehow auto-change last_row upon change in rows (and vice versa).\n\nExample:\n\njulia> gt=GTPattern([[2,1,0],[2,1],[2]])\n│ 2   1   0 ╲\n│   2   1    〉\n│     2     ╱\n\n\njulia> gt.rows\n3-element Vector{Vector{Int64}}:\n [2, 1, 0]\n [2, 1]\n [2]\n\njulia> gt.last_row\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"type"},{"location":"documentation/#GroupFunctions.su2_block","page":"Documentation","title":"GroupFunctions.su2_block","text":"su2_block(size::Int, position::Int, angles::NTuple{3,Float64})\nsu2_block(size::Int, indices::NTuple{2,Int}, angles::NTuple{3,Float64})\n\nEmbed a 2×2 SU(2) rotation defined by Euler angles (α, β, γ) into a size × size identity matrix.\n\nMethod 1: Adjacent indices\n\nsu2_block(size, position, angles) acts on rows/cols position and position+1.\n\nMethod 2: Arbitrary indices\n\nsu2_block(size, (i, j), angles) acts on rows/cols i and j where 1 ≤ i < j ≤ size. This allows creating SU(2) blocks at non-adjacent positions.\n\nExamples\n\n# Adjacent indices (traditional usage)\nmat = su2_block(4, 2, (0.1, 0.2, 0.3))  # acts on rows/cols (2, 3)\n\n# Non-adjacent indices\nmat = su2_block(5, (1, 4), (0.1, 0.2, 0.3))  # acts on rows/cols (1, 4)\n\n\n\n\n\n","category":"function"},{"location":"documentation/#AbstractAlgebra.YoungTableau","page":"Documentation","title":"AbstractAlgebra.YoungTableau","text":"Construct Young tableau from a given GTPattern.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.axialdistance","page":"Documentation","title":"GroupFunctions.axialdistance","text":"axialdistance(Y::YoungTableau, i, j)\n\nReturn the hook-length of an element in Y at position (i,j), i.e the number of cells in the i-th row to the right of (i,j)-th box, plus the number of cells in the j-th column below the (i,j)-th box, plus 1.Return 0 for (i,j) not in the tableau Y.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> axialdistance(y, 1,1)\n6\n\njulia> axialdistance(y, 1,3)\n3\n\njulia> axialdistance(y, 2,4)\n0\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.determine_position","page":"Documentation","title":"GroupFunctions.determine_position","text":"matrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n3×4 SparseArrays.SparseMatrixCSC{Int64,Int64} with 8 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  5\n  [3, 1]  =  8\n  [1, 2]  =  2\n  [2, 2]  =  6\n  [1, 3]  =  3\n  [2, 3]  =  7\n  [1, 4]  =  4\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.first_young_tableau_lexicographic","page":"Documentation","title":"GroupFunctions.first_young_tableau_lexicographic","text":"first_young_tableau_lexicographic(YoungTableau) -> YoungTableau\nComputes the first ---in lexicographic order---\nStandard Tableaux.\n\nExamples:\n\njulia> pat = YoungTableau([2,1])\njulia> primero_lexi(pat)\n┌───┬───┬\n│ 1 │ 3 │\n├───┼───┼\n│ 2 │\n├───┼\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.StandardYoungTableaux","page":"Documentation","title":"GroupFunctions.StandardYoungTableaux","text":"StandardYoungTableaux(part::Array{Int64,1}) -> list of YoungTableaux\n\nReturn a list of Standard YoungTableaux.\n\nExamples:\n\njulia> StandardYoungTableaux([2,1])\n[1 3; 2 0]\n[1 2; 3 0]\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.index_of_semistandard_tableau","page":"Documentation","title":"GroupFunctions.index_of_semistandard_tableau","text":"index_of_semistandard_tableau(p::YoungTableau)\nwas: indice_tablon_semistandard\n\nReturns the index of the standard YoungTableau such that the function mapping the filling of the semistandard to the standard Tableau is non decreasing\n\nTODO add examples\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.basis_states","page":"Documentation","title":"GroupFunctions.basis_states","text":"basis_states(weight::Row)\nGenerate basis states (GTPatterns) of a given representation.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.determine_next_pattern","page":"Documentation","title":"GroupFunctions.determine_next_pattern","text":"determine_next_pattern(x::GTPattern)\n\nwas: siguientepatron Determine next GT pattern by decreasing one entry (if possible) and propagating the change to rows below. Note: With incomplete patterns e.g. GTPattern([[2,1,0],[2,0]]) outputs of determinenextpattern and determinenextpattern! differ.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.determine_next_pattern!","page":"Documentation","title":"GroupFunctions.determine_next_pattern!","text":"determine_next_pattern!(x::GTPattern)\n\nwas: siguientepatron! Determine next GT pattern by decreasing one entry (if possible) and propagating the change to rows below.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.zweight","page":"Documentation","title":"GroupFunctions.zweight","text":"Computes zweight of a GTPattern. This array, if applied to each state of the irrep, is commonly known as the weight diagram of an SU(n) irrep.\n\nzweight(x::GTPattern)\n\nExamples:\n\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2])\njulia> zweight(t)\n>[0.5,0.5]\n\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.pweight","page":"Documentation","title":"GroupFunctions.pweight","text":"Computes pweight of a GTPattern. This array is related to the occupation number.\n\npweight(x::GTPattern)\n\nExamples:\n\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2])\njulia> pweight(t)\n>[0,1,2]\n\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.content","page":"Documentation","title":"GroupFunctions.content","text":"content(y::YoungTableau, λ::Irrep) -> Vector{Int}\n\nReturn the content vector sized to max(length(y.fill), length(λ)). In simple terms: it counts how many times each label (1, 2, 3, ...) appears in the tableau, padding as needed to match the irrep length.\n\nExamples:\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,2]);\njulia> content(t, [2,1,0])\n3-element Vector{Int64}:\n 1\n 2\n 0\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,1,2]);\njulia> content(t, [3])\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\ncontent(p::YoungTableau) -> Vector{Int}\n\nReturn the content vector of the tableau fill (counts of each label). In simple terms: it counts how many times each label (1, 2, 3, ...) appears in the tableau.\n\nExamples:\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,2]);\njulia> content(t)\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.Θ","page":"Documentation","title":"GroupFunctions.Θ","text":"Θ(patron_semi::YoungTableau)\n\nComputes coefficient Θ. Returns a Float64\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.generate_matrix","page":"Documentation","title":"GroupFunctions.generate_matrix","text":"generate_matrix(Y::Array{YoungTableau}, p::Perm, λ::Array{Int64,1}) -> SparseMatrixCSC\n\nReturn non-zero entries of the orthogonal irrep given by the permutation 'p' The information of the irrep is introduced via 'Y' which is a list of Standard Young tableaux\n\nExamples\n\njulia> guilty = StandardYoungTableaux([3,2])\njulia> generate_matrix(guilty, Perm([2,1,3,4,5]), [3,2])\n[1, 1]  =  -1.0\n[2, 2]  =  1.0\n[3, 3]  =  -1.0\n[4, 4]  =  1.0\n[5, 5]  =  1.0\n\njulia> generate_matrix(guilty, Perm([1,3,2,4,5]), [3,2])\n[1, 1]  =  0.5\n[2, 1]  =  0.866025\n[1, 2]  =  0.866025\n[2, 2]  =  -0.5\n[3, 3]  =  0.5\n[4, 3]  =  0.866025\n[3, 4]  =  0.866025\n[4, 4]  =  -0.5\n[5, 5]  =  1.0\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.su2_factorization","page":"Documentation","title":"GroupFunctions.su2_factorization","text":"su2_factorization(size::Int; skip_tail::Int = 0)\n\nBuild a random size × size unitary (SU(d)) as a product of SU(2) blocks; setting skip_tail skips the last skip_tail layers of factors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.sud_from_angles","page":"Documentation","title":"GroupFunctions.sud_from_angles","text":"sud_from_angles(angles::Vector{Float64}, size::Int; quotient::Bool = false)\n\nConstruct an SU(d) matrix from a supplied list of Euler angles, optionally zeroing the earliest layers when quotient is true.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.su2_block_symbolic","page":"Documentation","title":"GroupFunctions.su2_block_symbolic","text":"su2_block_symbolic(size::Int, position::Int; prefix::String = \"v\")\nsu2_block_symbolic(size::Int, indices::NTuple{2,Int}; prefix::String = \"v\")\n\nCreate a symbolic size × size matrix with a generic 2×2 block represented by symbolic variables. The rest of the matrix is an identity.\n\nThis is the symbolic analog of su2_block, where instead of numeric angles, the 2×2 block elements are symbolic variables. This is useful for symbolic computations similar to how group_function creates symbolic expressions in terms of matrix elements u_i_j.\n\nMethod 1: Adjacent indices\n\nsu2_block_symbolic(size, position; prefix) creates a 2×2 block at position and position+1.\n\nMethod 2: Arbitrary indices\n\nsu2_block_symbolic(size, (i, j); prefix) creates a 2×2 block at rows/cols i and j where 1 ≤ i < j ≤ size. This allows creating symbolic blocks at non-adjacent positions.\n\nArguments\n\nsize::Int: Dimension of the square matrix\nposition::Int: Starting row/column for the 2×2 block (must satisfy 0 < position < size)\nindices::NTuple{2,Int}: Tuple (i, j) specifying arbitrary row/column indices\nprefix::String: Prefix for symbolic variable names (default: \"v\")\n\nReturns\n\nMatrix{Basic}: A symbolic matrix with identity everywhere except a 2×2 symbolic block\n\nExamples\n\njulia> using GroupFunctions, SymEngine\n\n# Adjacent indices (traditional usage)\njulia> mat = su2_block_symbolic(3, 1)\n3×3 Matrix{Basic}:\n v_1_1  v_1_2  0\n v_2_1  v_2_2  0\n     0      0  1\n\n# Non-adjacent indices\njulia> mat = su2_block_symbolic(5, (1, 4))\n5×5 Matrix{Basic}:\n v_1_1  0  0  v_1_4  0\n     0  1  0      0  0\n     0  0  1      0  0\n v_4_1  0  0  v_4_4  0\n     0  0  0      0  1\n\njulia> mat = su2_block_symbolic(4, 2, prefix=\"w\")\n4×4 Matrix{Basic}:\n 1      0      0      0\n 0  w_2_2  w_2_3      0\n 0  w_3_2  w_3_3      0\n 0      0      0      1\n\nNotes\n\nThe symbolic variables are named \\$(prefix)_i_j where i,j are the row and column indices\nUnlike su2_block, this does not enforce SU(2) constraints (unitarity, determinant = 1)\nThe resulting matrix can be used in symbolic group function computations\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.julia_to_mma","page":"Documentation","title":"GroupFunctions.julia_to_mma","text":"julia_to_mma(expr::SymEngine.Basic)\n\nConvert a SymEngine expression using u_i_j symbols into a Mathematica-style string using u[i,j], adding light operator spacing for readability.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.mma_to_julia","page":"Documentation","title":"GroupFunctions.mma_to_julia","text":"mma_to_julia(s::String)\n\nConvert a Mathematica-style string using x[i,j] into a SymEngine expression with u_i_j symbols.\n\nExample:\n\njulia> mma_to_julia(\"x[1, 1]\")\nu_1_1\n\n\n\n\n\n","category":"function"},{"location":"qubit_transmission/#Example:-SU(2)-invariant-qubit-transmission","page":"Example: qubit transmission","title":"Example: SU(2)-invariant qubit transmission","text":"This example demonstrates encoding a qubit in four optical modes such that arbitrary polarization mixing during fiber transmission does not affect the logical state. The protocol uses two photons distributed across four modes, where modes 1–2 and 3–4 each experience the same unknown unitary U.\n\nThe protocol can be summarized as:\n\nState initialization of 2 photons across four modes: alpha2000rangle + beta0002rangle,\nPreprocessing: balanced beamsplitter on modes (2,3), then swap modes (1,2),\nTransmission through a fiber: first modes (1,2), modelling horizontal and vertical polarization, then (3,4). Both pairs undergo identical transformation U, so the total is Uoplus U.\nPotprocessing through swap of modes (1,2), then beamsplitter on modes (1,4).\nPostselection on detecting 0 photons in mode 1, 1 photon in mode 4.\n\nWith this, the resulting state is alpha0101rangle + beta0011rangle — the original qubit in modes 2–3, independent of U. The probability is affected by the exact form of U, but the normalization is irrelevant under postselection.","category":"section"},{"location":"qubit_transmission/#Implementation","page":"Example: qubit transmission","title":"Implementation","text":"First, set up the Hilbert space and identify the relevant Fock states:\n\nusing GroupFunctions\nusing SymEngine\nusing LinearAlgebra: I\n\n# Two photons in four modes\nλ = [2, 0, 0, 0]\nbasis = basis_states(λ)\n\n# Helper: find pattern by occupation\nstate(occ) = basis[findfirst(b -> pweight(b) == occ, basis)]\n\n# Initial and postselected states\ninitial_1 = state([2,0,0,0])\ninitial_2 = state([0,0,0,2])\nfinal_1   = state([0,1,0,1])\nfinal_2   = state([0,0,1,1])\n\nNext, construct the optical circuit symbolically. The fiber unitary U is left as a symbolic 2times 2 matrix, embedded block-diagonally to act identically on both mode pairs:\n\n# Build symbolic unitaries\nM_23 = bs_block_symbolic(4, 2)           # BS on modes 2-3\nS_12 = swap_block_symbolic(4, 1)         # swap modes 1-2\nM_14 = bs_block_symbolic(4, (1, 4))      # BS on modes 1-4 (non-adjacent)\n\n# Unknown fiber unitary: symbolic 2×2 block, embedded block-diagonally\nU_2x2 = su2_block_symbolic(2, 1, prefix=\"u\")\nU_fiber = Matrix{Basic}(I, 4, 4)\nU_fiber[1:2, 1:2] = U_2x2[1:2, 1:2]\nU_fiber[3:4, 3:4] = U_2x2[1:2, 1:2]\n\n# Full transformation\nU_total = M_14 * S_12 * U_fiber * S_12 * M_23\n\nNow compute the transition amplitudes. Since the initial state is a superposition alpha2000rangle + beta0002rangle, we compute the amplitudes for each computational basis state separately:\n\n# Compute symbolic transition amplitudes\namp_11 = group_function_sym(λ, final_1, initial_1, U_total)  # |2,0,0,0⟩ → |0,1,0,1⟩\namp_12 = group_function_sym(λ, final_2, initial_1, U_total)  # |2,0,0,0⟩ → |0,0,1,1⟩\namp_21 = group_function_sym(λ, final_1, initial_2, U_total)  # |0,0,0,2⟩ → |0,1,0,1⟩\namp_22 = group_function_sym(λ, final_2, initial_2, U_total)  # |0,0,0,2⟩ → |0,0,1,1⟩\n\nprintln(\"α|2,0,0,0⟩ → |0,1,0,1⟩: \", amp_11)\nprintln(\"α|2,0,0,0⟩ → |0,0,1,1⟩: \", amp_12)\nprintln(\"β|0,0,0,2⟩ → |0,1,0,1⟩: \", amp_21)\nprintln(\"β|0,0,0,2⟩ → |0,0,1,1⟩: \", amp_22)","category":"section"},{"location":"qubit_transmission/#Interpreting-the-result","page":"Example: qubit transmission","title":"Interpreting the result","text":"By linearity, the full output state (conditioned on postselection) is obtained by superposing the contributions:\n\npsi_mathrmoutrangle propto alpha bigl(mathrmamp_110101rangle + mathrmamp_120011ranglebigr) + beta bigl(mathrmamp_210101rangle + mathrmamp_220011ranglebigr)\n\nThe symbolic calculation reveals that mathrmamp_12 = mathrmamp_21 = 0 and mathrmamp_11 = mathrmamp_22 equiv A, where A is independent of the fiber unitary U. The postselected state therefore simplifies to:\n\npsi_mathrmoutrangle = frac1mathcalNbigl(alpha0101rangle + beta0011ranglebigr)\n\nwhere mathcalN = Asqrtalpha^2 + beta^2 is a normalization factor arising from the postselection probability. The qubit encoded in modes 2–3 is recovered with its original coefficients alpha and beta, regardless of the unknown transformation U applied during transmission.","category":"section"},{"location":"immanants/#Immanants","page":"Immanants","title":"Immanants","text":"First discovered by Kostant and then extended by de Guise et al., immanants of unitary matrices can be computed by certain sums of group functions.\n\nBriefly, in this section of the documentation, I give some examples of this relation. First, compute the unitary matrix:\n\nα1,β1,γ1 = rand(Float64,3)\nblock12_a = su2_block(4,1,(α1,β1,γ1))\nα2,β2 = rand(Float64,2)\nblock23_a = su2_block(4,2,(α2,β2,α2))\nα3,β3,γ3 = rand(Float64,3)\nblock12_b = su2_block(4,1,(α3,β3,γ3))\nα4,β4 = rand(Float64,3)\nblock34_a = su2_block(4,3,(α4,β4,α4))\nα5,β5 = rand(Float64,2)\nblock23_b = su2_block(4,2,(α5,β5,α5))\nα6,β6,γ6 = rand(Float64,3)\nblock12_c = su2_block(4,1,(α6,β6,γ6))\n\nmat4 = block12_a * block23_a * block12_b * block34_a * block23_b * block12_c\n\nThen obtain the states with a given p-weight (see the Alex et al. paper).\n\nbasis = basis_states([3,0,0,0])\n\nstate_x = filter(x -> pweight(x) == [0,1,1,1], basis)[1]\nstate_y = filter(x -> pweight(x) == [1,0,2,0], basis)[1]\n\nFinally, show the equality between the permanent and a group function.\n\ngroup_function([3,0,0,0], state_x, state_y, mat4) ≈ permanent(mat4[[1,2,3], [2,2,4]])/sqrt(2)","category":"section"},{"location":"quantum_optics/#Basic-quantum-optics-using-GroupFunctions.jl","page":"Example: HOM effect","title":"Basic quantum optics using GroupFunctions.jl","text":"","category":"section"},{"location":"quantum_optics/#Introduction","page":"Example: HOM effect","title":"Introduction","text":"Linear optical networks (beamsplitters, phase shifters, etc. )act on n optical modes via SU(n) transformations. A key object is the transition amplitude between Fock states under such transformations.\n\nConsider N photons distributed across n modes. The Fock state m_1 m_2 ldots m_nrangle with sum_i m_i = N transforms under passive linear optics as: m_1 ldots m_nrangle xrightarrowU sum_m c_mm(U) m_1 ldots m_nrangle where U in mathrmSU(n) mixes the mode creation operators: a^dagger_i mapsto sum_j U_ij a^dagger_j.\n\nThe amplitudes c_mm(U) are matrix elements of SU(n) irreducible representations, specifically, the symmetric irrep lambda = N 0 ldots 0, corresponding to a single-row Young tableau. This is because bosonic states are symmetric under particle exchange. Importantly, for symmetric irreps, the p-weight of a Gelfand-Tsetlin pattern (used internally by this library) directly gives the occupation numbers, more natural in quantum optics.  \n\nThe basic items to translate between quantum optics and GT pattern language are thus the following:\n\nDefine photon number subspace  λ = [N, 0, ..., 0] \nEnumerate the basis of the above subspace using GT patterns  basis = basis_states(λ) \nEach of the basis elements corresponds to the Fock state with occupation number provided by  pweight(pattern) \nTransition amplitude is read out by group_function(λ, final, initial, U), where U is the SU(n) unitary in previous paragraphs (e.g. provided by su2_block(n, i, (α, β, γ))), final and initial are the final and initial states (written as GT patterns).","category":"section"},{"location":"quantum_optics/#Basis-states-and-occupation-numbers","page":"Example: HOM effect","title":"Basis states and occupation numbers","text":"The Hilbert space of N photons in n modes has dimension binomN+n-1n-1. We enumerate basis states as GT patterns:\n\nusing GroupFunctions\n\n# Two photons in three modes\nλ = [2, 0, 0]\nbasis = basis_states(λ)\n\n# Each GT pattern corresponds to a Fock state via pweight\nfor b in basis\n    occ = pweight(b)\n    println(\"|\", join(occ, \",\"), \"⟩\")\nend\n\nExpected output:\n\n|2,0,0⟩\n|1,1,0⟩\n|1,0,1⟩\n|0,2,0⟩\n|0,1,1⟩\n|0,0,2⟩","category":"section"},{"location":"quantum_optics/#Building-SU(n)-matrices","page":"Example: HOM effect","title":"Building SU(n) matrices","text":"Any SU(n) matrix can be decomposed into SU(2) blocks acting on adjacent modes. The function su2_block(n, i, (α, β, γ)) embeds an SU(2) rotation (parametrized by Euler angles) into modes i and i+1:\n\n# Beamsplitter on modes 1-2 (θ = π/2 for 50:50)\nθ = float(π)/2\nBS_12 = su2_block(3, 1, (0., θ, 0.))\n\n# Beamsplitter on modes 2-3\nBS_23 = su2_block(3, 2, (0., θ, 0.))\n\n# Compose: first BS_12, then BS_23\nU = BS_12 * BS_23\n\nTODO: Verify sign/phase conventions for su2_block. The beamsplitter mixing a^dagger_1 mapsto frac1sqrt2(a^dagger_1 + a^dagger_2) corresponds to which Euler angles?","category":"section"},{"location":"quantum_optics/#Transition-amplitudes","page":"Example: HOM effect","title":"Transition amplitudes","text":"The amplitude langle m  U  m rangle is computed via group_function:\n\nλ = [2, 0, 0]\nbasis = basis_states(λ)\n\n# Initial state: |2,0,0⟩\ninitial = basis[findfirst(b -> pweight(b) == [2,0,0], basis)]\n\n# Final state: |1,1,0⟩\nfinal = basis[findfirst(b -> pweight(b) == [1,1,0], basis)]\n\n# Amplitude\namp = group_function(λ, final, initial, U)\nprob = abs2(amp)","category":"section"},{"location":"quantum_optics/#Example:-Hong-Ou-Mandel-interference","page":"Example: HOM effect","title":"Example: Hong-Ou-Mandel interference","text":"Two photons entering a 50:50 beamsplitter from different input ports:\n\nInitial state: 11rangle\nBeamsplitter: a^dagger_1 mapsto frac1sqrt2(a^dagger_1 + a^dagger_2), a^dagger_2 mapsto frac1sqrt2(a^dagger_1 - a^dagger_2)\n\nλ = [2, 0]\nbasis = basis_states(λ)\n\ninitial = basis[findfirst(b -> pweight(b) == [1,1], basis)]\n\nθ = float(π)/2\nBS = su2_block(2, 1, (0., θ, 0.))\n\nfor final in basis\n    amp = group_function(λ, final, initial, BS)\n    println(\"|\", join(pweight(final), \",\"), \"⟩: \", round(abs2(amp), digits=4))\nend\n\nExpected (HOM effect): The 11rangle to 11rangle amplitude vanishes due to destructive interference. Output is frac1sqrt2(20rangle + 02rangle).\n\nTODO: Verify output matches expected HOM signature. Check if beamsplitter convention gives the correct phases.","category":"section"},{"location":"characters/#Characters","page":"Characters","title":"Characters","text":"SU(d) characters can be evaluated with the Weyl/Schur determinant formula.","category":"section"},{"location":"characters/#Example:-SU(3)-character-check","page":"Characters","title":"Example: SU(3) character check","text":"using GroupFunctions\nusing RandomMatrices\nusing LinearAlgebra: det, eigvals, tr\n\nirrep = [2, 1, 0]\nU = rand(Haar(2), 3)  # 3×3 Haar-random unitary matrix\nU_su = U / det(U)^(1 / 3)\n\nrep, _states = group_function(irrep, U_su)\nlambdas = eigvals(U_su)\nideal_character = lambdas[1] / lambdas[2] + lambdas[2] / lambdas[1] +\n                  lambdas[1] / lambdas[3] + lambdas[3] / lambdas[1] +\n                  lambdas[2] / lambdas[3] + lambdas[3] / lambdas[2] + 2\ntr(rep) ≈ ideal_character","category":"section"},{"location":"characters/#Example:-variance-of-Weyl-character-samples","page":"Characters","title":"Example: variance of Weyl character samples","text":"using GroupFunctions\nusing RandomMatrices\nusing LinearAlgebra: det\nusing Statistics: var\n\nnsamples = 1_000\nn = 3\nirrep = [2, 1, 0]\n\nvalues = Vector{ComplexF64}(undef, nsamples)\nfor i in 1:nsamples\n    U = rand(Haar(2), n)\n    U_su = U / det(U)^(1 / n)\n    values[i] = character_weyl(irrep, U_su)\nend\n\nvariance = var(values)\n# Expect variance ≈ 1 for these samples.\nvariance","category":"section"},{"location":"characters/#GroupFunctions.character_weyl","page":"Characters","title":"GroupFunctions.character_weyl","text":"character_weyl(λ::Irrep, mat::Array{Complex{Float64},2}) -> ComplexF64\n\nCompute the U(n) character using the Weyl/Schur determinant formula, without using the characteristic polynomial.\n\nNotes\n\nmat must be square; the length of λ must not exceed size(mat,1).\nThe formula evaluates the Schur polynomial at the eigenvalues of mat: det(z_i^(λ_j+n-j)) / det(z_i^(n-j)).\n\n\n\n\n\n","category":"function"},{"location":"sum_rules/#Sum-rules","page":"Sum rules","title":"Sum rules","text":"First, prepare the matrix using the simple factorization.\n\nα1,β1,γ1 = rand(Float64,3)\nblock12_a = su2_block(4,1,(α1,β1,γ1))\nα2,β2 = rand(Float64,2)\nblock23_a = su2_block(4,2,(α2,β2,α2))\nα3,β3,γ3 = rand(Float64,3)\nblock12_b = su2_block(4,1,(α3,β3,γ3))\nα4,β4 = rand(Float64,3)\nblock34_a = su2_block(4,3,(α4,β4,α4))\nα5,β5 = rand(Float64,2)\nblock23_b = su2_block(4,2,(α5,β5,α5))\nα6,β6,γ6 = rand(Float64,3)\nblock12_c = su2_block(4,1,(α6,β6,γ6))\n\nmat4 = block12_a * block23_a * block12_b\nmat4c1 = block12_a * block23_a * block12_b * block34_a * block23_b\n\nThen obtain the basis states:\n\nbasis = basis_states([2,0,0,0])\n\nFinally, compute the rate:\n\nrate1 = abs(group_function([2,0,0,0], basis[9], basis[9], mat4))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[4], mat4))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[7], mat4))^2\nrate2 = abs(group_function([2,0,0,0], basis[9], basis[9], mat4c1))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[4], mat4c1))^2 +\n        abs(group_function([2,0,0,0], basis[9], basis[7], mat4c1))^2\nrate1 ≈ rate2","category":"section"},{"location":"states/#States","page":"Basis states","title":"States","text":"The preferred method to denote the basis states is by using Gelfand–Tsetlin patterns.   Without going into detail, this can be seen in the paper by Alex et al.   The top row of the pattern is the partition that labels the irrep.   The rest of the entries should satisfy the betweenness condition, explained below.  \n\nI start with an example. (Due to LaTeX limitations, I denote the pattern as left-justified.)   The pattern is:  \n\nbeginpmatrix\nc_00  c_01  c_02 \nc_10  c_11  \nc_20    \nendpmatrix\n\nThe betweenness condition imposes the requirement:\n\nc_i-1j geq c_ij geq c_i-1j+1\n\nTo introduce a GTPattern, write an array of arrays with the content of the pattern as the argument:\n\nGTPattern([[2,1,0], [2,1], [2]])","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Build Status) (Image: )","category":"section"},{"location":"#Overview","page":"Getting started","title":"Overview","text":"A Julia package for computing matrix elements of irreducible representations of the unitary group U(n), commonly known as D-functions or group functions. Supports both numerical evaluation and symbolic computation. Potential applications include quantum information and quantum optics problems (boson sampling, photonic state preparation), as well as general quantum many-body physics. \n\nThe basic functionality of the function is the following: given a (symbolic or numerical) U(n) matrix, calculate the transformation matrix in a given representation (e.g. fixed particle number subspace), mathematically described via basis states involving Gelfand-Tseltsin patterns.\n\nAs a quick example, the following code calculates the probability of photonic ket11 state transforming to ket20 photons after going through a 50:50 beamsplitter.\n\nusing GroupFunctions\n\nλ = [2, 0]                           # 2 photons, 2 modes\nbasis = basis_states(λ)              # enumerate GT patterns\n\n# Check which Fock state each pattern represents\nfor b in basis\n    println(pweight(b), \" → \", b)    # pweight gives occupation numbers\nend\n# Output: [2,0], [1,1], [0,2]\n\n# Beamsplitter unitary and transition amplitude |1,1⟩ → |2,0⟩\nBS = su2_block(2, 1, (0., π/2, 0.))\ninitial = basis[findfirst(b -> pweight(b) == [1,1], basis)]\nfinal   = basis[findfirst(b -> pweight(b) == [2,0], basis)]\n\namp = group_function(λ, final, initial, BS)\nprintln(\"Probability: \", abs2(amp))  # ≈ 0.5 (HOM effect)","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"If this is your first time using Julia, please refer to the language documentation and tutorials. Until the package is registered, please use the manual installation using git URL: open up julia, and within the interpreter perform the following:\n\njulia> # here you need to press the character `]`; the prompt turns blue\npkg> add https://github.com/davidamaro/GroupFunctions.jl\n\nRequires Julia ≥ 1.6.","category":"section"},{"location":"#Contact","page":"Getting started","title":"Contact","text":"Questions and suggestions: david.amaroalcala@ucalgary.ca","category":"section"},{"location":"#References","page":"Getting started","title":"References","text":"","category":"section"}]
}
