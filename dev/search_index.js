var documenterSearchIndex = {"docs":
[{"location":"immanants/#Immanants","page":"Immanants","title":"Immanants","text":"First discovered by Kostant  and then extended by de Guise et al,  immanants of unitary matrices can be computed by certain sums of group functions.\n\nBriefly, in this section of the documentation, I give some examples of this relation. First, I compute the unitary matrix:\n\n    α1,β1,γ1 = rand(Float64,3)\n    xx=bloquesun(4,1,(α1,β1,γ1))\n    α2,β2 = rand(Float64,2)\n    yy=bloquesun(4,2,(α2,β2,α2))\n    α3,β3,γ3 = rand(Float64,3)\n    zz=bloquesun(4,1,(α3,β3,γ3))\n    α4,β4 = rand(Float64,3)\n    xx2=bloquesun(4,3,(α4,β4,α4))\n    α5,β5 = rand(Float64,2)\n    yy2=bloquesun(4,2,(α5,β5,α5))\n    α6,β6,γ6 = rand(Float64,3)\n    zz2=bloquesun(4,1,(α6,β6,γ6))\n\n    mat4 = xx*yy*zz*xx2*yy2*zz2\n\nThen I obtain the states with certain p-weight (see Alex et al paper).\n\n    welcome = basis_states([3,0,0,0])\n\n    edox = filter(x -> pweight(x) == [0,1,1,1] , welcome)[1]\n    edoy = filter(x -> pweight(x) == [1,0,2,0], welcome)[1]\n\nFinally, I show the equality between the permanent and a group function.\n\n    group_function([3,0,0,0], edox, edoy, mat4) ≈ permanent(mat4[[1,2,3], [2,2,4]])/sqrt(2)","category":"section"},{"location":"sum_rules/#Sum-rules","page":"Sum rules","title":"Sum rules","text":"First, prepare the matrix using the simple factorization.\n\n    α1,β1,γ1 = rand(Float64,3)\n    xx=bloquesun(4,1,(α1,β1,γ1))\n    α2,β2 = rand(Float64,2)\n    yy=bloquesun(4,2,(α2,β2,α2))\n    α3,β3,γ3 = rand(Float64,3)\n    zz=bloquesun(4,1,(α3,β3,γ3))\n    α4,β4 = rand(Float64,3)\n    xx2=bloquesun(4,3,(α4,β4,α4))\n    α5,β5 = rand(Float64,2)\n    yy2=bloquesun(4,2,(α5,β5,α5))\n    α6,β6,γ6 = rand(Float64,3)\n    zz2=bloquesun(4,1,(α6,β6,γ6))\n\n    mat4 = xx*yy*zz\n    mat4c1 = xx*yy*zz*xx2*yy2\n\nThen obtain the basis states:\n\n    welcome = basis_states([2,0,0,0])\n\nFinally, compute the rate\n\n    rate1 = abs( group_function([2,0,0,0], welcome[9], welcome[9], mat4) )^2 + abs( group_function([2,0,0,0], welcome[9], welcome[4], mat4) )^2 + abs( group_function([2,0,0,0], welcome[9], welcome[7], mat4) )^2\n    rate2 = abs( group_function([2,0,0,0], welcome[9], welcome[9], mat4c1) )^2 + abs( group_function([2,0,0,0], welcome[9], welcome[4], mat4c1) )^2 + abs( group_function([2,0,0,0], welcome[9], welcome[7], mat4c1) )^2\n    rate1 ≈ rate2","category":"section"},{"location":"states/#States","page":"Basis states","title":"States","text":"The preferred method to denote the basis states is by using Gelfand–Tsetlin patterns.   Without going into detail, this can be seen in the paper by Alex et al.   The top row of the pattern is the partition that labels the irrep.   The rest of the entries should satisfy the betweenness condition, which I now explain.  \n\nI start with an example. (Due to LaTeX limitations, I denote the pattern as left-justified.)   The pattern is:  \n\nbeginpmatrix\nc_00  c_01  c_02 \nc_10  c_11  \nc_20    \nendpmatrix\n\nThe betweenness condition imposes the requirement: \n\nc_i-1j geq c_ij geq c_i-1j+1\n\nTo introduce a GTPattern, simply write an array of arrays with the content of the pattern as argument:\n\nGTPattern([[2,1,0], [2,1], [2]])","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Build Status) (Image: )","category":"section"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"Julia package to compute entries of the irreducible representations of the unitary group (D-functions or group functions). It supports both numerical and symbolical group functions.","category":"section"},{"location":"#[Documentation](https://davidamaro.github.io/GroupFunctions.jl/dev/)","page":"Getting started","title":"Documentation","text":"","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"#Julia-is-already-installed","page":"Getting started","title":"Julia is already installed","text":"Alternatively, you can install the package directly from the repository:\n\nuser@machine:~$ mkdir new_code \nuser@machine:~$ cd new_code\nuser@machine:~$ julia --project=.\njulia> # here you need to press the character `]`; the prompt turns blue\npkg > add https://github.com/davidamaro/GroupFunctions.jl","category":"section"},{"location":"#Getting-Julia","page":"Getting started","title":"Getting Julia","text":"Mac: Use juliaup. Installing Julia via brew is not recommended.\nLinux: Use the appropriate package manager (e.g., sudo pacman -S julia).\nWindows: Run winget install julia -s msstore in your terminal and follow the steps.","category":"section"},{"location":"#Computing-a-single-group-function-(symbolical)","page":"Getting started","title":"Computing a single group function (symbolical)","text":"my_fav_irrep = [2, 1, 0]\nmy_fav_basis = basis_states(my_fav_irrep)\noutput = group_function(my_fav_irrep, my_fav_basis[1], my_fav_basis[3])\njulia_to_mma(output)","category":"section"},{"location":"#Contact","page":"Getting started","title":"Contact","text":"For questions and suggestions : david.amaroalcala@ucalgary.ca","category":"section"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/#Functions","page":"Documentation","title":"Functions","text":"","category":"section"},{"location":"documentation/#Gelfand-Tsetlin-patterns","page":"Documentation","title":"Gelfand-Tsetlin patterns","text":"GT patterns are used to denote the basis states.","category":"section"},{"location":"documentation/#Construction-of-matrices","page":"Documentation","title":"Construction of matrices","text":"GT patterns are used to denote the basis states.","category":"section"},{"location":"documentation/#GroupFunctions.group_function","page":"Documentation","title":"GroupFunctions.group_function","text":"group_function(λ::Irrep, tu::YoungTableau, tv::YoungTableau)\n\nReturns the symbolic group function corresponding to irrep λ and Young tableaux tu and tv.\n\nExample:\n\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, tab_u::YTableau, tab_v::YTableau; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Young tableaux and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\ntab_u::YTableau: First Young tableau\ntab_v::YTableau: Second Young tableau\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nComplex: Group function evaluated\n\nNotes:\n\nUses SymEngine for symbolic computation\nInvolves matrix operations and coset calculations\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern)\n\nReturns the symbolic group function corresponding to irrep λ and GT patterns tu and tv.\n\nExample:\n\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t)\n\ngroup_function(λ::Irrep, pat_u::GTPattern, pat_v::GTPattern; verbose::Bool = false) -> Basic\n\nCompute group theoretical function based on Gelfand-Tsetlin patterns and irreducible representations.\n\nArguments:\n\nλ::Irrep: Irreducible representation\npat_u::GTPattern: First Gelfand-Tsetlin pattern\npat_v::GTPattern: Second Gelfand-Tsetlin pattern\nverbose::Bool: Flag for detailed output (default: false)\n\nReturns:\n\nBasic: Computed polynomial expression in SymEngine format\n\nNotes:\n\nConverts GT patterns to Young tableaux for calculations\nUses SymEngine for symbolic computation\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and a pair of GT patterns tu and tv.\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = GTPattern([[2,1,0],[2,1],[2]],[2]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\ngroup_function(λ::Irrep, tu::GTPattern, tv::GTPattern, mat::Array{Complex{Float64},2})\n\nReturns the numeric group function, for an SU(n) member mat, corresponding to irrep λ and STYT tu and tv.\n\nExample:\n\njulia> using RandomMatrices\njulia> mat = rand(Haar(2),3)\njulia> t = YoungTableau([2,1]); fill!(t, [1,2,3]);\njulia> group_function([2,1,0], t, t, mat)\n\n\n\n\n\n","category":"function"},{"location":"documentation/#GroupFunctions.GTPattern","page":"Documentation","title":"GroupFunctions.GTPattern","text":"GTPattern(arrayofarrays) Stucture to hold Gelfand-Tsetlin patterns.  Data fields:\n\nrows\nlast_row, copied from rows during initialization (for internal algorithm purposes, mathematically irrelevant)\n\nTODO: either make it immutable, or somehow auto-change last_row upon change in rows (and vice versa).\n\nExample:\n\njulia> gt=GTPattern([[2,1,0],[2,1],[2]])\n│ 2 1 0 ╲\n│ 2 1    〉\n│ 2     ╱\n\n\njulia> gt.rows\n3-element Vector{Vector{Int64}}:\n [2, 1, 0]\n [2, 1]\n [2]\n\njulia> gt.last_row\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"type"},{"location":"documentation/#GroupFunctions.bloquesun","page":"Documentation","title":"GroupFunctions.bloquesun","text":"bloquesun(size::Int64, position::Int64, angles::Tuple{Float64,Float64,Float64})\n\nComputes the SU(2) matrix using angles an embeds it into a size times size matrix.\n\nExample:\n\nα5,β5 = rand(Float64,2)\nyy2=bloquesun(4,2,(α5,β5,α5))\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Index","page":"Index","title":"Index","text":"","category":"section"}]
}
