<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculation of group functions · GroupFunctions documentation</title><meta name="title" content="Calculation of group functions · GroupFunctions documentation"/><meta property="og:title" content="Calculation of group functions · GroupFunctions documentation"/><meta property="twitter:title" content="Calculation of group functions · GroupFunctions documentation"/><meta name="description" content="Documentation for GroupFunctions documentation."/><meta property="og:description" content="Documentation for GroupFunctions documentation."/><meta property="twitter:description" content="Documentation for GroupFunctions documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="GroupFunctions documentation logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="GroupFunctions documentation logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../states/">Basis states</a></li><li class="is-active"><a class="tocitem" href>Calculation of group functions</a><ul class="internal"><li><a class="tocitem" href="#The-problem:-mode-mixing-in-quantum-mechanics"><span>The problem: mode mixing in quantum mechanics</span></a></li><li><a class="tocitem" href="#Bosons:-the-permanent"><span>Bosons: the permanent</span></a></li><li><a class="tocitem" href="#Fermions:-the-determinant"><span>Fermions: the determinant</span></a></li><li><a class="tocitem" href="#The-general-formula"><span>The general formula</span></a></li></ul></li><li><a class="tocitem" href="../quantum_optics/">Example: HOM effect</a></li><li><a class="tocitem" href="../qubit_transmission/">Example: qubit transmission</a></li><li><a class="tocitem" href="../characters/">Characters</a></li><li><a class="tocitem" href="../sum_rules/">Sum rules</a></li><li><a class="tocitem" href="../immanants/">Immanants</a></li><li><a class="tocitem" href="../flavor/">Example: flavor mixing</a></li></ul></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Calculation of group functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculation of group functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/davidamaro/GroupFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/davidamaro/GroupFunctions.jl/blob/master/docs/src/group_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Group-Functions"><a class="docs-heading-anchor" href="#Group-Functions">Group Functions</a><a id="Group-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Group-Functions" title="Permalink"></a></h1><h2 id="The-problem:-mode-mixing-in-quantum-mechanics"><a class="docs-heading-anchor" href="#The-problem:-mode-mixing-in-quantum-mechanics">The problem: mode mixing in quantum mechanics</a><a id="The-problem:-mode-mixing-in-quantum-mechanics-1"></a><a class="docs-heading-anchor-permalink" href="#The-problem:-mode-mixing-in-quantum-mechanics" title="Permalink"></a></h2><p>Consider a system of <span>$n$</span> modes, each described by a creation operator <span>$a^\dagger_i$</span>. A Fock state is built by applying creation operators to the vacuum:</p><p class="math-container">\[|m_1, m_2, \ldots, m_n\rangle = \frac{(a_1^\dagger)^{m_1} \cdots (a_n^\dagger)^{m_n}}{\sqrt{m_1! \cdots m_n!}} |0\rangle.\]</p><p>Now suppose the modes get mixed by a unitary transformation <span>$U \in \mathrm{U}(n)$</span>: <span>$a_i^\dagger \mapsto \sum_j U_{ij} a_j^\dagger.$</span></p><p>What is the output state? Each creation operator in the original Fock state transforms according to the rule above. Expanding the product, we obtain a superposition of Fock states with coefficients that are polynomials in the matrix elements <span>$U_{ij}$</span>.</p><p>The function <code>group_function</code> computes these coefficients — the transition amplitudes <span>$\langle m&#39; | U | m \rangle$</span>. The presentation here is slightly more mathematical than a typical quantum optics treatment, for consistency with representation theory literature and to handle more general cases beyond bosons.</p><h2 id="Bosons:-the-permanent"><a class="docs-heading-anchor" href="#Bosons:-the-permanent">Bosons: the permanent</a><a id="Bosons:-the-permanent-1"></a><a class="docs-heading-anchor-permalink" href="#Bosons:-the-permanent" title="Permalink"></a></h2><p>For bosonic systems, consider the transition amplitude between an input Fock state <span>$|m\rangle$</span> and an output Fock state <span>$|m&#39;\rangle$</span>, both having <span>$N$</span> total particles. We follow the derivation of <a href="https://arxiv.org/abs/quant-ph/0406127">Scheel (2004)</a>.</p><p>Label the <span>$N$</span> particles by <span>$\alpha = 1, \ldots, N$</span>, assigning each to its input mode via <span>$\alpha \mapsto i_\alpha$</span> such that mode <span>$i$</span> appears <span>$m_i$</span> times (so, e.g. for <span>$\ket{2,1,0}$</span>, <span>$(i_1, i_2, i_3)=(1,1,2)$</span>). Then:</p><p class="math-container">\[U|m\rangle = \frac{1}{\sqrt{\prod_i m_i!}} \prod_{i=1}^{n} \left(\sum_j U_{ij} a_j^\dagger\right)^{m_i} |0\rangle = \frac{1}{\sqrt{\prod_i m_i!}} \sum_{j_1, \ldots, j_N} \left(\prod_{\alpha=1}^{N} U_{i_\alpha, j_\alpha}\right) \prod_{\alpha=1}^N a_{j_\alpha}^\dagger |0\rangle\]</p><p>The first step unfolds powers into labeled factors; the second is distributivity. </p><p>So now we have products of operators acting on the vacuum <span>$\ket{0}$</span>; we wish to close it with a bra <span>$\bra{m&#39;}$</span> to calculate the matrix element. Let us act with the creatio operators on the vacuum and identify terms proportional to <span>$\ket{m&#39;}$</span> there; then, the matrix element will be a sum of prefactors leading to <span>$\ket{m&#39;}$</span>.  For terms where the tuple <span>$(j_1, \ldots, j_N)$</span> contains mode <span>$k$</span> exactly <span>$m&#39;_k$</span> times, the creation operators produce:</p><p class="math-container">\[\prod_{\alpha=1}^N a_{j_\alpha}^\dagger |0\rangle = \sqrt{\prod_j m&#39;_j!}\, |m&#39;\rangle\]</p><p>The <span>$\sqrt{m&#39;_j!}$</span> arises because <span>$m&#39;_j$</span> identical creation operators acting on vacuum give <span>$(a_j^\dagger)^{m&#39;_j}|0\rangle = \sqrt{m&#39;_j!}|m&#39;_j\rangle_j$</span>. Denoting the constraint on <span>$(j_1, \ldots, j_N)$</span> as <span>$\sim m&#39;$</span>:</p><p class="math-container">\[\langle m&#39; | U | m \rangle = \frac{\sqrt{\prod_j m&#39;_j!}}{\sqrt{\prod_i m_i!}} \sum_{(j_1,\ldots,j_N) \sim m&#39;} \prod_{\alpha=1}^{N} U_{i_\alpha, j_\alpha}\]</p><p>The above expression can be shown to be expressible as a permanent of a properly constructed matrix. This is, by the way, the basis for boson sampling problems; computing the permanent is #P-hard (<a href="https://arxiv.org/abs/1011.3245">Aaronson &amp; Arkhipov, 2011</a>), making bosonic transition amplitudes classically intractable.</p><p>The relation is as follows: construct an <span>$N \times N$</span> matrix <span>$M$</span> using output labeling <span>$\beta \mapsto j_\beta$</span> (analogous to input): <span>$M_{\alpha\beta} = U_{i_\alpha, j_\beta}$</span>. The permanent sums over all permutations <span>$\sigma \in S_N$</span>:</p><p class="math-container">\[\mathrm{perm}(M) = \sum_{\sigma \in S_N} \prod_{\alpha=1}^{N} U_{i_\alpha, j_{\sigma(\alpha)}}\]</p><p>Each valid <span>$(j_1, \ldots, j_N) \sim m&#39;$</span> corresponds to <span>$\prod_j m&#39;_j!$</span> permutations (permuting indices within each output mode). Therefore: <span>$\sum_{(j_1,\ldots,j_N) \sim m&#39;} \prod_{\alpha} U_{i_\alpha, j_\alpha} = \frac{\mathrm{perm}(M)}{\prod_j m&#39;_j!}$</span></p><p>As a result, we have</p><p class="math-container">\[\langle m&#39; | U | m \rangle = \frac{\mathrm{perm}(M)}{\sqrt{\prod_i m_i!}\sqrt{\prod_j m&#39;_j!}}\]</p><p><strong>Example:</strong> 3 modes, input <span>$|m\rangle = |2,0,1\rangle$</span>, output <span>$|m&#39;\rangle = |1,1,1\rangle$</span>.</p><p>Input labeling (<span>$N=3$</span> particles): <span>$(i_1, i_2, i_3) = (1, 1, 3)$</span> — two particles from mode 1, one from mode 3.</p><p>Output labeling: <span>$(j_1, j_2, j_3) = (1, 2, 3)$</span> — one particle into each mode.</p><p>The matrix <span>$M$</span> has entries <span>$M_{\alpha\beta} = U_{i_\alpha, j_\beta}$</span>:</p><p class="math-container">\[M = \begin{pmatrix} U_{11} &amp; U_{12} &amp; U_{13} \\ U_{11} &amp; U_{12} &amp; U_{13} \\ U_{31} &amp; U_{32} &amp; U_{33} \end{pmatrix}\]</p><p>Note the repeated rows from <span>$m_1 = 2$</span>.</p><p>In representation-theoretic terms, bosonic Fock states live in the symmetric subspace, the irrep <span>$\lambda = [N, 0, \ldots, 0]$</span>.</p><h2 id="Fermions:-the-determinant"><a class="docs-heading-anchor" href="#Fermions:-the-determinant">Fermions: the determinant</a><a id="Fermions:-the-determinant-1"></a><a class="docs-heading-anchor-permalink" href="#Fermions:-the-determinant" title="Permalink"></a></h2><p>For fermions, the derivation parallels the bosonic case with three modifications: occupation numbers are restricted to <span>$m_i, m&#39;_j \in \{0,1\}$</span> (Pauli exclusion), leading to all normalization factors become <span>$\sqrt{0!}=\sqrt{1!} = 1$</span>, and anticommutation introduces signs.</p><p>The expansion step has the aame structure as bosons:</p><p class="math-container">\[U|m\rangle = \sum_{j_1, \ldots, j_N} \left(\prod_{\alpha=1}^{N} U_{i_\alpha, j_\alpha}\right) a_{j_1}^\dagger \cdots a_{j_N}^\dagger |0\rangle\]</p><p>To project the result to final bra <span>$\bra{m&#39;}$</span>, consider the following. For a term to contribute to <span>$|m&#39;\rangle$</span>, the tuple <span>$(j_1, \ldots, j_N)$</span> must have all distinct entries (otherwise <span>$a_j^\dagger a_j^\dagger = 0$</span>), forming a permutation of the occupied output modes. Write <span>$j_\alpha = j&#39;_{\sigma(\alpha)}$</span> where <span>$(j&#39;_1, \ldots, j&#39;_N)$</span> is the sorted list and <span>$\sigma \in S_N$</span>. Reordering to standard form introduces signs from the anticommutation relation (rectifying every transposition changes it: <span>$a_2^\dagger a_1^\dagger=-a_1^\dagger a_2^\dagger$</span>):</p><p class="math-container">\[a_{j_1}^\dagger \cdots a_{j_N}^\dagger |0\rangle = \mathrm{sgn}(\sigma) \cdot a_{j&#39;_1}^\dagger \cdots a_{j&#39;_N}^\dagger |0\rangle = \mathrm{sgn}(\sigma) |m&#39;\rangle\]</p><p>As a result,</p><p class="math-container">\[\langle m&#39; | U | m \rangle = \sum_{\sigma \in S_N} \mathrm{sgn}(\sigma) \prod_{\alpha=1}^{N} U_{i_\alpha, j&#39;_{\sigma(\alpha)}} = \det(M)\]</p><p>where <span>$M_{\alpha\beta} = U_{i_\alpha, j&#39;_\beta}$</span> is the submatrix of <span>$U$</span> with rows = occupied input modes, columns = occupied output modes.</p><p>Unlike permanents, determinants can be computed efficiently in <span>$O(N^3)$</span> time, which underlies the tractability of free-fermion systems.</p><h2 id="The-general-formula"><a class="docs-heading-anchor" href="#The-general-formula">The general formula</a><a id="The-general-formula-1"></a><a class="docs-heading-anchor-permalink" href="#The-general-formula" title="Permalink"></a></h2><p>Both results share a common structure: a sum over permutations, weighted by representation-dependent coefficients, times a monomial in matrix elements. For bosons:</p><p class="math-container">\[\langle m&#39; | U | m \rangle \propto \sum_{\sigma \in S_N} 1 \cdot \prod_{\alpha} U_{i_\alpha, j_{\sigma(\alpha)}}\]</p><p>and for fermions:</p><p class="math-container">\[\langle m&#39; | U | m \rangle \propto \sum_{\sigma \in S_N} \mathrm{sgn}(\sigma) \cdot \prod_{\alpha} U_{i_\alpha, j_{\sigma(\alpha)}}\]</p><p>The weights <span>$1$</span> and <span>$\mathrm{sgn}(\sigma)$</span> are the matrix elements of the trivial and sign representations of <span>$S_N$</span>, both one-dimensional.</p><p>For a general irrep <span>$\lambda$</span>, the representation has dimension <span>$f^\lambda &gt; 1$</span>, and the weight becomes a matrix element <span>$\omega^\lambda_{i,j}(\sigma)$</span> of the Young orthogonal representation. The general formula, due to <a href="https://doi.org/10.1007/BF00046717">Grabmeier &amp; Kerber (1985)</a>, is:</p><p class="math-container">\[T^\lambda_{U,V} = \frac{1}{\sqrt{\Theta^\lambda_U \Theta^\lambda_V}} \sum_{\gamma} \left( \sum_{\sigma \in S_\alpha \gamma S_\beta} \omega^\lambda_{i,j}(\sigma) \right) X_{f \circ \gamma, g}\]</p><p>Here <span>$U, V$</span> are semistandard tableaux labeling basis states (equivalent to GT patterns), <span>$\Theta$</span> is a normalization factor generalizing <span>$\sqrt{m!}$</span>, and <span>$X_{f \circ \gamma, g}$</span> is the monomial <span>$\prod_k U_{i_k, j_k}$</span>. The double coset decomposition <span>$S_\alpha \backslash S_N / S_\beta$</span> groups permutations contributing the same monomial.</p><p>The partition <span>$\lambda$</span> labels the symmetry type: <span>$[N]$</span> for bosons, <span>$[1^N]$</span> for fermions, mixed shapes for particles with mixed exchange symmetry. The function <code>group_function(λ, ...)</code> evaluates this formula.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../states/">« Basis states</a><a class="docs-footer-nextpage" href="../quantum_optics/">Example: HOM effect »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 20 January 2026 14:57">Tuesday 20 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
